var async = require("async");
var superagent = require("superagent");
var response = require("../../../utilities/response.manager");
let mongoConnection = require('../../../utilities/connections');
const constants = require("../../../utilities/constants");
const mime = require('mime');
let templates = require("../../../models/customers/templates/template.model");
let users = require("../../../models/customers/user.model");
let balanceModel = require("../../../models/customers/balanceuses.model");
let msgstatusModel = require("../../../models/customers/msgstatuses.model");
let countries = require("../../../models/customers/countries.model");
let successtransactions = require("../../../models/customers/successtransactions.model");
let customertransactions = require("../../../models/customers/customertransactions.model");
const transactions = require("../../../models/customers/transactions.model");
let leadsModel = require("../../../models/customers/leads.model");
let helper = require("../../../utilities/helper");
let config = require("../../../config");
let broadcasts = require('../../../models/customers/broadcasts.model');
let inBounds = require('../../../models/customers/inbound');
let messageEvents = require('../../../models/customers/messageevents.model');
let msgStatus = require("../../../models/customers/msgstatuses.model");
let endCustomers = require("../../../models/customers/end_customers.model");
let teammemberModel = require("../../../models/customers/team_members.model");
let rolesModel = require("../../../models/customers/role.model");
let permissionsModel = require("../../../models/customers/permission.model");
let commonMODEL = require("../../../models/customers/autoreplycrons.model");
let axios = require('axios');
let metaleadtemps = require("../../../models/customers/metaleadtemp.model");

const { BlobServiceClient } = require("@azure/storage-blob");
const { shopifyABCFunction } = require("../../../routes/openapis/shopifyABCSaud");
const blobServiceClient = BlobServiceClient.fromConnectionString(connStr);

const duplicateCustomers = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ database: "db_maioradiamonds_india" }).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    let secondary = mongoConnection.useDb(userData.database);
                    try {
                        console.log('userData.database :>> ', userData.database);
                        const duplicateCustomers = await secondary.model(constants.MODELS.endcustomers, endCustomers).aggregate([
                            { $match: { $or: [{ isDelete: false }, { isDelete: { $exists: false } }], mobileNo: { $type: "string", $regex: /^[0-9]+$/ } } },
                            {
                                $addFields: {
                                    lastNineDigits: {
                                        $cond: {
                                            if: { $gte: [{ $strLenCP: "$mobileNo" }, 10] },
                                            then: {
                                                $substrBytes: [
                                                    "$mobileNo",
                                                    { $subtract: [{ $strLenCP: "$mobileNo" }, 10] },
                                                    10
                                                ]
                                            },
                                            else: null
                                        }
                                    }
                                }
                            },
                            { $group: { _id: '$lastNineDigits', dups: { $push: "$_id" }, count: { $sum: 1 } } },
                            { $match: { count: { $gt: 1 } } }
                        ]);
                        console.log("duplicateCustomers :>> ", duplicateCustomers);
                        for (const group of duplicateCustomers) {
                            const dupsToKeep = await secondary.model(constants.MODELS.endcustomers, endCustomers).find({ _id: { $in: group.dups } }).select('chatUpdatedAt totalIncomingMessages totalOutgoingMessages customerLastMessagedAt mobileNo').lean();
                            if (dupsToKeep.length > 0) {
                                dupsToKeep.sort((a, b) => {
                                    if (a.customerLastMessagedAt > b.customerLastMessagedAt) {
                                        console.log("-------01");
                                        return -1;
                                    }
                                    if (a.customerLastMessagedAt < b.customerLastMessagedAt) {
                                        console.log("-------01");
                                        return 1;
                                    }
                                    if (a.totalIncomingMessages > b.totalIncomingMessages) {
                                        console.log("-------03");
                                        return -1;
                                    }
                                    if (a.totalIncomingMessages < b.totalIncomingMessages) {
                                        console.log(a.totalIncomingMessages, b.totalIncomingMessages);
                                        console.log("-------04");
                                        return 1;
                                    }
                                    if (a.totalOutgoingMessages > b.totalOutgoingMessages) {
                                        console.log("-------05");
                                        return -1;
                                    }
                                    if (a.totalOutgoingMessages < b.totalOutgoingMessages) {
                                        console.log("-------06");
                                        return 1;
                                    }
                                    if (a.mobileNo.startsWith("9191") && !b.mobileNo.startsWith("9191")) {
                                        return 1; // move a to the end
                                    }
                                    if (!a.mobileNo.startsWith("9191") && b.mobileNo.startsWith("9191")) {
                                        return -1; // move b to the end
                                    }
                                    if (a.mobileNo.length > b.mobileNo.length) {
                                        console.log("-------02");
                                        return -1;
                                    }
                                    if (a.mobileNo.length < b.mobileNo.length) {
                                        console.log("-------02");
                                        return 1;
                                    }
                                    console.log("-------07");
                                    return b.chatUpdatedAt - a.chatUpdatedAt;
                                });
                                console.log("dupsToKeep----->>>>>>>>>>>>>>>>>>>>>>>>>--------------------", dupsToKeep[0].mobileNo);
                                const dupsToDelete = dupsToKeep.slice(1);
                                const dupMobileNostoDelete = dupsToDelete.map((dupToDelete) => dupToDelete.mobileNo);
                                const dupIdsToDelete = dupsToDelete.map((dupToDelete) => dupToDelete._id);
                                console.log("dupMobileNostoDelete-----", dupMobileNostoDelete);
                                // console.log("dupIdsToDelete-----", dupIdsToDelete);
                                let datainbound = await secondary.model(constants.MODELS.inbounds, inBounds).find({ to: { $in: dupMobileNostoDelete } });
                                console.log("datainbound-----found", datainbound.length);
                                if (datainbound.length > 0) {
                                    await secondary.model(constants.MODELS.inbounds, inBounds).updateMany({ to: { $in: dupMobileNostoDelete } }, { $set: { to: dupsToKeep[0].mobileNo } });
                                }
                                if (dupIdsToDelete.length > 0) {
                                    await secondary.model(constants.MODELS.endcustomers, endCustomers).updateMany(
                                        { _id: { $in: dupIdsToDelete } },
                                        { $set: { isDelete: true, toKeep: true } }
                                    );
                                }
                            }
                        }
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const duplicateCustomersinEngees = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        try {
            const duplicateCustomers = await primary.model(constants.MODELS.allcustomers, endCustomers).aggregate([
                { $match: { $or: [{ isDelete: false }, { isDelete: { $exists: false } }], mobileNo: { $type: "string", $regex: /^[0-9]+$/ } } },
                {
                    $addFields: {
                        lastNineDigits: {
                            $cond: {
                                if: { $gte: [{ $strLenCP: "$mobileNo" }, 10] },
                                then: {
                                    $substrBytes: [
                                        "$mobileNo",
                                        { $subtract: [{ $strLenCP: "$mobileNo" }, 10] },
                                        10
                                    ]
                                },
                                else: null
                            }
                        }
                    }
                },
                { $group: { _id: '$lastNineDigits', dups: { $push: "$_id" }, count: { $sum: 1 } } },
                { $match: { count: { $gt: 1 } } }
            ]);
            console.log("duplicateCustomers :>> ", duplicateCustomers);
            for (const group of duplicateCustomers) {
                const dupsToKeep = await primary.model(constants.MODELS.allcustomers, endCustomers).find({ _id: { $in: group.dups } }).select('chatUpdatedAt totalIncomingMessages totalOutgoingMessages customerLastMessagedAt mobileNo').lean();
                if (dupsToKeep.length > 0) {
                    dupsToKeep.sort((a, b) => {
                        if (a.customerLastMessagedAt > b.customerLastMessagedAt) {
                            console.log("-------01");
                            return -1;
                        }
                        if (a.customerLastMessagedAt < b.customerLastMessagedAt) {
                            console.log("-------01");
                            return 1;
                        }
                        if (a.totalIncomingMessages > b.totalIncomingMessages) {
                            console.log("-------03");
                            return -1;
                        }
                        if (a.totalIncomingMessages < b.totalIncomingMessages) {
                            console.log(a.totalIncomingMessages, b.totalIncomingMessages);
                            console.log("-------04");
                            return 1;
                        }
                        if (a.totalOutgoingMessages > b.totalOutgoingMessages) {
                            console.log("-------05");
                            return -1;
                        }
                        if (a.totalOutgoingMessages < b.totalOutgoingMessages) {
                            console.log("-------06");
                            return 1;
                        }
                        if (a.mobileNo.startsWith("9191") && !b.mobileNo.startsWith("9191")) {
                            return 1; // move a to the end
                        }
                        if (!a.mobileNo.startsWith("9191") && b.mobileNo.startsWith("9191")) {
                            return -1; // move b to the end
                        }
                        if (a.mobileNo.length > b.mobileNo.length) {
                            console.log("-------02");
                            return -1;
                        }
                        if (a.mobileNo.length < b.mobileNo.length) {
                            console.log("-------02");
                            return 1;
                        }
                        console.log("-------07");
                        return b.chatUpdatedAt - a.chatUpdatedAt;
                    });
                    console.log("dupsToKeep----->>>>>>>>>>>>>>>>>>>>>>>>>--------------------", dupsToKeep[0].mobileNo);
                    const dupsToDelete = dupsToKeep.slice(1);
                    const dupMobileNostoDelete = dupsToDelete.map((dupToDelete) => dupToDelete.mobileNo);
                    const dupIdsToDelete = dupsToDelete.map((dupToDelete) => dupToDelete._id);
                    console.log("dupMobileNostoDelete-----", dupMobileNostoDelete);
                    if (dupIdsToDelete.length > 0) {
                        await primary.model(constants.MODELS.allcustomers, endCustomers).updateMany(
                            { _id: { $in: dupIdsToDelete } },
                            { $set: { isDelete: true, toKeep: true } }
                        );
                    }
                }
            }
        } catch (err) {
            console.log(err);
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const createContainer = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find().lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("userData----", userData.database, userData.mobileNo);
                        let str = userData.dataStore;
                        let result = str.substring(0, str.length - 37);
                        console.log(result);
                        const containerClient = blobServiceClient.getContainerClient(result);
                        const containerExists = await containerClient.exists();
                        console.log("containerExists----", containerExists);
                        if (!containerExists) {
                            await containerClient.create();
                            await containerClient.setAccessPolicy("blob");
                        }
                        // if (containerExists) {
                        //     const deleteContainerResponse = await containerClient.delete();
                        //     console.log(
                        //         'Container was deleted successfully. requestId: ',
                        //         deleteContainerResponse.requestId
                        //     );
                        // }
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}


const updateDataStoreName = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find().lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("userData----", userData.database, userData.mobileNo);
                        const containerName = userData.dataStoreOld
                        // let str = userData.dataStoreOld;
                        // let result = str.substring(0, str.length - 37);
                        // console.log(result);
                        await primary.model(constants.MODELS.users, users).updateOne({ _id: userData._id }, { $set: { dataStore: containerName, dataStoreOld: containerName } })

                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const addAdressinUsers = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ WABAname: { $exists: false } }).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("userData----", userData.database, userData.mobileNo);
                        let leadData = await primary.model('leads', leadsModel).findOne({ mobileNo: userData.mobileNo }).lean();
                        // if (leadData && leadData.business_Address) {
                        //     console.log("leadData.business_Addres", leadData.business_Address);
                        //     await primary.model(constants.MODELS.users, users).updateOne({ _id: userData._id }, { $set: { business_Address: leadData.business_Address } });
                        // }
                        console.log("leadData----", leadData);
                        if (leadData && leadData.WABAname) {
                            console.log("leadData.WABAname", leadData.WABAname);
                            // await primary.model(constants.MODELS.users, users).updateOne({ _id: userData._id }, { $set: { WABAname: leadData.WABAname } });
                        }
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const getLastestMessageStatusTime = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ database: 'db_fuegotrade_india' }).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("user Details============>>>", userData.database, userData.mobileNo);
                        let secondary = mongoConnection.useDb(userData.database);
                        let timestampNew = await secondary.model(constants.MODELS.msgstatus, msgStatus).find({}).sort({ _id: -1 }).limit(10).lean();

                        // Extract the timestamp from the database result
                        // const createdAt = timestampNew[0].createdAt;

                        // // Convert UTC time to Indian Standard Time
                        // // Convert UTC time to Indian Standard Time
                        // const indianTime = new Date(createdAt);
                        // indianTime.setUTCHours(indianTime.getUTCHours() + 5); // Adding 5 hours to UTC hours
                        // indianTime.setUTCMinutes(indianTime.getUTCMinutes() + 30); // Adding additional 30 minutes to UTC minutes

                        // // Format the date object to a readable string
                        // const formattedTime = indianTime.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
                        if (timestampNew.length == 0) {
                            console.log("No entries found");
                        } else {
                            console.log(timestampNew);
                        }
                        // console.log(formattedTime); // This will log the timestamp in Indian Standard Time

                        // let timestampNew = await secondary.model(constants.MODELS.msgstatus, msgStatus).countDocuments({createdAt: {$gte: currentDate}})
                        // if (timestampNew == 0){
                        //     console.log("No entries found for last month");
                        // }else{
                        //     console.log("Entries found for last month", timestampNew);
                        // }
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const addPlanDetails = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ "planDetails": { $exists: false } }).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("user Details============>>>", userData.database, userData.mobileNo);
                        let planDetails = {
                            "planType": {
                                "type": "quarterly",
                                "name": "QUARTERLY",
                                "duration": 3
                            },
                            "startDate": "2023-12-31T18:30:00.000Z"
                        }
                        await primary.model(constants.MODELS.users, users).updateOne({ _id: userData._id }, { $set: { planDetails: planDetails } });
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const addAdminTransactionDetails = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({}).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("user Details============>>>", userData.database, userData.mobileNo);
                        let secondary = mongoConnection.useDb(userData.database);
                        let regextoInclude = new RegExp('admin_', "i");
                        let adminTransactionData = await secondary.model(constants.MODELS.successtransactions, successtransactions)
                            .find({ transactionId: { $regex: regextoInclude } }).lean();
                        let newArray = adminTransactionData;
                        if (newArray.length > 0) {
                            newArray.forEach((transaction) => {
                                delete transaction._id;
                                transaction['parentId'] = config.mongoose.Types.ObjectId(userData._id);
                                // transaction['createdAt'] = new Date(transaction['createdAt']);
                                // transaction['updatedAt'] = new Date(transaction['updatedAt']);
                            })
                            console.log("newAdminTransactionData", newArray);
                            await primary.model(constants.MODELS.customertransactions, customertransactions).insertMany(newArray);
                        }
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}
const abcHitShopify = async () => {
    // const url = process.env.APPURI + '/apis/shopifyAbcCron';
    // console.log('url----', url);
    // axios.post(url)
    //     .then((response) => {
    //         console.log("response----", response.data);
    //     })
    //     .catch((error) => {
    //         console.error('error', error)
    //     });
    shopifyABCFunction();
}

const addPermissionExport111 = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({}).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    try {
                        console.log("user Details============>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", userData.database, userData.mobileNo);
                        let secondary = mongoConnection.useDb(userData.database);
                        let { _id: administratorId } = await secondary.model(constants.MODELS.roles, rolesModel).findOne({ name: "Administrator" }).select('_id').lean();
                        let permissions = await secondary.model(constants.MODELS.permissions, permissionsModel).findOne({ roleId: administratorId }).lean();
                        console.log("administratorId", administratorId, permissions && "foundData");
                        let permissionArray = [];
                        if (permissions.permission && permissions.permission.length > 0) {
                            permissionArray = permissions.permission.map((elObj) => {
                                if (elObj.hasOwnProperty('export')) {
                                    console.log("have Export key++++++++++");
                                    return elObj;
                                } else {
                                    console.log("dont have Export key---------");
                                    if (elObj.insertUpdate == true) {
                                        elObj['export'] = true;
                                    } else {
                                        elObj['export'] = false;
                                    }
                                    return elObj;
                                }
                            })
                        }
                        console.log("permissionArray", permissionArray.length);
                        await secondary.model(constants.MODELS.permissions, permissionsModel).updateOne({ roleId: administratorId }, { $set: { permission: permissionArray } });
                    } catch (err) {
                        console.log(err);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const addPermissionExport = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({}).lean();

        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    console.log("User Details:------>>>>>>>>>>>>>>", userData.database, userData.mobileNo);
                    let secondary = mongoConnection.useDb(userData.database);
                    let administrator = await secondary.model(constants.MODELS.roles, rolesModel).findOne({ name: "Administrator" }).select('_id').lean();

                    if (administrator) {
                        secondary.model(constants.MODELS.permissions, permissionsModel).findOne({ roleId: administrator._id }).lean().then(async (permissions) => {
                            if (permissions) {
                                console.log("Administrator ID:", administrator._id);
                                let permissionArray = [];

                                if (permissions && permissions.permission && permissions.permission.length > 0) {
                                    permissionArray = permissions.permission.map((elObj) => {
                                        // delete elObj._id;
                                        if (elObj.hasOwnProperty('export')) {
                                            console.log("Have Export key");
                                            return elObj;
                                        } else {
                                            console.log("Don't have Export key");
                                            if (elObj.insertUpdate == true) {
                                                elObj['export'] = true;
                                            } else {
                                                elObj['export'] = false;
                                            }
                                            return elObj;
                                        }
                                    });
                                }

                                console.log("Permission Array Length:", permissionArray.length);
                                let permissionsArray1 = JSON.parse(JSON.stringify(permissionArray));
                                console.log(permissions._id, permissionsArray1);
                                let permissionsUpdate = await secondary.model(constants.MODELS.permissions, permissionsModel).findByIdAndUpdate(permissions._id, { $set: { permission: permissionsArray1 } }, { new: true }).lean();
                                console.log("permissionsUpdate", permissionsUpdate);
                            }
                        });

                        console.log("Permissions updated successfully");
                    } else {
                        console.log("Administrator role not found for user:", userData.mobileNo);
                    }
                } else {
                    console.log('User not found');
                }
            } catch (error) {
                console.error('Error during getting user details:', error);
            }
        }

        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in addPermissionExport:', error);
    }
}

const updateWalletPermission = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({}).lean();

        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    console.log("User Details:------>>>>>>>>>>>>>>", userData.database, userData.mobileNo);
                    let secondary = mongoConnection.useDb(userData.database);
                    let administrator = await secondary.model(constants.MODELS.roles, rolesModel).findOne({ name: "Administrator" }).select('_id').lean();
                    let newPermission = ["interactivegroups",
                        "optinsetting",
                        "walletrequests",
                        "openapilogs",
                        "chats",
                        "label"];
                    let toUpdate = true;
                    if (administrator) {
                        // secondary.model(constants.MODELS.permissions, permissionsModel).findOne({ roleId: '6208a6ccb5925815b5d2e61c' }).lean().then(async (permissions) => {
                        secondary.model(constants.MODELS.permissions, permissionsModel).findOne({ roleId: administrator._id }).lean().then(async (permissions) => {
                            if (permissions) {
                                console.log("Administrator ID:", administrator._id);
                                let permissionArray = JSON.parse(JSON.stringify(permissions.permission));
                                console.log("before-------------------------", permissions.permission.length);
                                // console.log("before----array", permissions.permission);

                                if (permissions && permissions.permission && permissions.permission.length > 0) {
                                    newPermission.forEach(newPerm => {
                                        const existingPerm = permissionArray.find(el => el.collectionName === newPerm);

                                        if (existingPerm) {
                                            console.log("----1 updating", newPerm);
                                            // Update existing permission object
                                            // if (newPerm === 'interactivegroups' || newPerm === 'optinsetting') {
                                            existingPerm.export = true;
                                            // }
                                            // if (newPerm === 'walletrequests' || newPerm === 'chats') {
                                            existingPerm.delete = true;
                                            // }
                                            // if (newPerm === 'openapilogs' || newPerm === 'chats') {
                                            existingPerm.insertUpdate = true;
                                            existingPerm.view = true;
                                            // }
                                            // Mark that an update occurred
                                        } else {
                                            console.log("----2 adding", newPerm);
                                            // Create a new permission object if it doesn't exist
                                            let obj = {
                                                collectionName: newPerm,
                                                insertUpdate: true,
                                                delete: true,
                                                view: true,
                                                export: true,
                                                _id: config.mongoose.Types.ObjectId()
                                            };
                                            // if (newPerm === 'interactivegroups' || newPerm === 'optinsetting') {
                                            //     obj.export = false;
                                            // }
                                            // if (newPerm === 'walletrequests' || newPerm === 'chats') {
                                            //     obj.delete = false;
                                            // }
                                            // if (newPerm === 'openapilogs' || newPerm === 'chats') {
                                            //     obj.insertUpdate = false;
                                            // }
                                            permissionArray.push(obj);
                                        }
                                    });

                                }

                                if (toUpdate) {
                                    console.log("Permission Array Length: after", permissionArray.length);
                                    let permissionsArray1 = JSON.parse(JSON.stringify(permissionArray));
                                    console.log('after---- array', permissionsArray1);
                                    let permissionsUpdate = await secondary.model(constants.MODELS.permissions, permissionsModel).findByIdAndUpdate(permissions._id, { $set: { permission: permissionsArray1 } }, { new: true }).lean();
                                    // console.log("permissionsUpdate", permissionsUpdate);
                                    console.log("Permissions updated successfully");
                                }
                            }
                        });
                    } else {
                        console.log("Administrator role not found for user:", userData.mobileNo);
                    }
                } else {
                    console.log('User not found');
                }
            } catch (error) {
                console.error('Error during getting user details:', error);
            }
        }

        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in addPermissionExport:', error);
    }
}
// razorpay_payment_id check in all database
const razorpay_payment_id = async (req, res) => {
    try {
        console.log('=-------------------------------------');
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({}).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo && userData.database) {
                    console.log(userData.mobileNo, userData.database);
                    const secondary = mongoConnection.useDb(userData.database);
                    // const getAllData1 = await secondary.model(constants.MODELS.transactions, transactions).find({ "razorpay_payment_id": "_O6Msviq9DWGN30" });
                    const getAllData1 = await secondary.model(constants.MODELS.successtransactions, successtransactions).find({ "razorpay_payment_id": "_O6Msviq9DWGN30" });
                    console.log(getAllData1);
                }
            } catch (err) {
                console.error('error during updating template status', err)
            }
        }
        // return response.onSuccess('success', 1, res);
    } catch (error) {
        console.log(error);
        // return response.onError(error, res);
    }
};

const addpermissionobjectinTeammembers = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        let query = { queueMember: { $exists: false, $in: [null, '', undefined] }, 'archiveMember': { $exists: false, $in: [null, '', undefined] }, isSuperAdmin: true };
        let notification = {
            "chat": true,
            "order": true,
            "queue": true,
            "payment": true,
            "broadcast": true,
            "autoreply": true
        };
        let allTeammembers = await primary.model(constants.MODELS.teammembers, teammemberModel).find(query).lean();
        // await primary.model(constants.MODELS.teammembers, teammemberModel).updateMany(query, { $set: { notification: notification } });
        console.log(allTeammembers);
        console.log("allTeammembers", allTeammembers.length);
        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in addPermissionExport:', error);
    }
}


const userswithonlywlletfalseandstatustrue = async (req, res) => {
    try {
        console.log('=-------------------------------------');
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ "isWallet": { $in: [false, '', null] }, "accountStatus": true }).select('mobileNo companyName -_id').lean();
        console.log(JSON.stringify(alluserdata));
        // return response.onSuccess('success', 1, res);
    } catch (error) {
        console.log(error);
        // return response.onError(error, res);
    }
};

const keyAddMetaTemp = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ facebook_page_id: { $ne: "" } }).lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    let secondary = mongoConnection.useDb(userData.database);
                    let metaLeadTemp = await secondary.model(constants.MODELS.metaleadtemps, metaleadtemps).countDocuments({ template: { $exists: true } }).lean();
                    if (metaLeadTemp) {
                        console.log("----------------------------", userData.database);
                        console.log("metaLeadTemp Count---", metaLeadTemp);
                        // await secondary.model(constants.MODELS.metaleadtemps, metaleadtemps).updateMany({ template: { $exists: true } }, { $set: { "template.status": true } });
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details')
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const testLoop = async () => {
    try {
        const axiosFunction = (jsonData) => {
            try {
                console.log("Request data sent");
                superagent
                    .post("https://statusmsg-dev.11za.in/statusmsgs/6208a6ccb5925815b5d2e618")
                    .send(jsonData)
                    .then(response => {
                        console.log("response", response.status);
                    })
                    .catch(error => {
                        console.error("Error posting data", error);
                    });
            } catch (error) {
                console.error("Unexpected error", error);
            }
        };

        const promises = [];
        let startTime = new Date().getTime();
        console.log("start time", startTime);
        console.log("start time", new Date(startTime).toISOString());
        console.log("start time", new Date(startTime).toLocaleString("en-US", { timeZone: "Asia/Kolkata" }));
        for (let i = 0; i < 20000; i++) {
            promises.push(axiosFunction({
                "messageId": "e2b3a5aa-1471-46b6-9f5c-c642bd295850",
                "channel": "whatsapp",
                "event": "MessageStatus::accepted",
                "deliveryChannel": "whatsapp",
                "status": "accepted",
                "timestamp": "2024-05-21T07:19:22.299Z",
                "to": "918807936698"
            }));

            promises.push(axiosFunction({
                "messageId": "e2b3a5aa-1471-46b6-9f5c-c642bd295850",
                "channel": "whatsapp",
                "event": "MessageStatus::delivered",
                "deliveryChannel": "whatsapp",
                "status": "delivered",
                "timestamp": "2024-05-21T07:19:23Z",
                "to": "918807936698",
                "whatsapp": {
                    "conversation": {
                        "conversationId": "32e4d635b126771875a0baa65181b7d1",
                        "origin": "service",
                        "expiresAt": "2024-05-22T07:13:00Z"
                    },
                    "conversationId": "32e4d635b126771875a0baa65181b7d1",
                    "pricingModel": "CBP",
                    "billable": true
                },
                "details": { "from": "918866186841" },
                "from": "918866186841"
            }));

            // promises.push(axiosFunction({
            //     "messageId": "e2b3a5aa-1471-46b6-9f5c-c642bd295850",
            //     "channel": "whatsapp",
            //     "event": "MessageStatus::seen",
            //     "deliveryChannel": "whatsapp",
            //     "status": "seen",
            //     "timestamp": "2024-05-21T07:19:23.050Z",
            //     "to": "918807936698",
            //     "details": { "from": "918866186841" },
            //     "from": "918866186841"
            // }));
        }

        await Promise.all(promises);
        let endTime = new Date().getTime();
        console.log("end time", endTime);
        console.log("Difference", (endTime - startTime) / 1000);
        console.log("All requests have been processed");
    } catch (error) {
        console.error("Error in testLoop", error);
    }
};

const newLoop = async () => {
    const superagentFunction = async (jsonData) => {
        try {
            await superagent
                .post("https://statusmsg-dev.11za.in/statusmsgs/6208a6ccb5925815b5d2e618")
                .send(jsonData);
            console.log("Request successful");
        } catch (error) {
            console.error("Error posting data", error);
        }
    };

    const jsonDataTemplate = {
        "messageId": "e2b3a5aa-1471-46b6-9f5c-c642bd295850",
        "channel": "whatsapp",
        "event": "MessageStatus::accepted",
        "deliveryChannel": "whatsapp",
        "status": "accepted",
        "timestamp": "2024-05-21T07:19:22.299Z",
        "to": "918807936698"
    };

    const requests = Array(75000).fill(jsonDataTemplate);

    const processRequestsInBatches = async (requests, batchSize, interval) => {
        for (let i = 0; i < requests.length; i += batchSize) {
            const batch = requests.slice(i, i + batchSize);
            const promises = batch.map(data => superagentFunction(data));
            await Promise.all(promises);
            await new Promise(resolve => setTimeout(resolve, interval));
        }
    };

    processRequestsInBatches(requests, 100, 5000);
};

const addReferenceIdfromleadstoCustomers = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const allLeadsData = await primary.model(constants.MODELS.leads, leadsModel).find({ reference: { $exists: true } }).lean();
        for (let leadData of allLeadsData) {
            if (leadData && leadData.reference) {
                console.log("leadData", leadData.reference);
                // await primary.model(constants.MODELS.users, users).updateOne({ mobileNo: leadData.mobileNo }, { $set: { reference: leadData.reference } })
            }
        }
    } catch (error) {
        console.error("Error in testLoop", error);
    }
};
let arr1 = [
    // "db_aambyvalley_india",
    "db_accuaisoftwareprivatelimited_india"
    , "db_aics_india"
    , "db_anjalitextilemills_india"
    , "db_ankpal_india"
    , "db_arhamshareprivatelimited_india"
    , "db_astrosubhashsharma_india"
    , "db_blackbunny_india"
    , "db_brandcircusevents_india"
    , "db_celestehomesalons_india"
    , "db_daduvaanifashion_india"
    , "db_fabculture_india"
    , "db_farmhousehub_india"
    , "db_gfivedesignerscouturepvtltd_india"
    , "db_gujaratitrade_india"
    , "db_himsonpetrosyntheticsltd_india"
    , "db_hisabkitab_india"
    , "db_iaxntelecomprivatelimited_india"
    , "db_ivygrowth_india"
    , "db_ivygrowthassociates_india"
    , "db_jitoincubationandinnovationfoundation_india"
    , "db_maioradiamonds_india"
    , "db_odtradesoft_india"
    , "db_projectshades_india"
    , "db_reelwalestudio_india"
    , "db_salarcares_india"
    , "db_shreemahalaxmifashion_india"
    , "db_shringharcreation_india"
    , "db_stockboxtechnologiesprivatelimited_india"
    , "db_swadcooking_india"
    , "db_tulsiresinstore_india"
    , "db_vastraapp02_india"
    , "db_weshine_india"
    , "db_whitelion_india"
    , "db_yashasvidesigner_india"
    , "db_zoivanepets_india"
    , "db_zoraware_india"
    , "db_zorkoprivatelimited_india"]


let noDedicatedPod = [
    // "db_09taxconsultancy_india",
    "db_41india_india"
    , "db_aanchi_india"
    , "db_abdesignsjewellery_india"
    , "db_abhiraajrealtors_india"
    , "db_accelerateforxcellenceprivatelimited_india"
    , "db_actipass_india"
    , "db_adkrity_india"
    , "db_adviselocollabstudiosprivatelimited_india"
    , "db_agarwalagency_india"
    , "db_agarwalpragatitrust_india"
    , "db_agarwalvikastrust_india"
    , "db_ajvafintechprivatelimited_india"
    , "db_amartex_india"
    , "db_anahitahospitalityllp_india"
    , "db_araviorganic_india"
    , "db_arcedior_india"
    , "db_arihantfashion_india"
    , "db_arihantfashion2_india"
    , "db_avgamlearningprivatelimited_india"
    , "db_bandhanivilla_india"
    , "db_bhadewala_india"
    , "db_bknenterpriseprivatelimited_india"
    , "db_blockskillo_india"
    , "db_bluenodeinfotechprivatelimited_india"
    , "db_bnisurat_india"
    , "db_candorivfcenterprivatelimited_india"
    , "db_capturinghappinesspvtltd_india"
    , "db_chikankarichic_india"
    , "db_chinulalandsons_india"
    , "db_choudharypropertyconsultant_india"
    , "db_chplgroup3_india"
    , "db_chunariyacollection_india"
    , "db_clothiq_india"
    , "db_cmansukhlaljewellers_india"
    , "db_code16jeans_india"
    , "db_compassionatechoicesprivatelimited_india"
    , "db_curvylanellp_india"
    , "db_dahleez_india"
    , "db_dailyfithealthtechprivatelimited_india"
    , "db_dermaconahmedabad2027_india"
    , "db_dhananjaybathfittingindai_india"
    , "db_dheertamarketing2_india"
    , "db_dheertamarketing3_india"
    , "db_dheertamarketing4_india"
    , "db_dholakiatechnologiesllp_india"
    , "db_dia_india"
    , "db_dimodaa_india"
    , "db_drgreenayurved_india"
    , "db_dronaarcheryandrifleshootingacademy_india"
    , "db_easyonservices_india"
    , "db_easytech_india"
    , "db_embcart_india"
    , "db_emmanuelresortspvtltd_india"
    , "db_enlightenangelfundprivatelimited_india"
    , "db_ethnicsupply_india"
    , "db_evoke_india"
    , "db_fabcartzindia_india"
    , "db_fabrichub_india"
    , "db_fabricnfabric_india"
    , "db_flourishinternationalprivatelimited_india"
    , "db_fourcellenergyprivatelimited_india"
    , "db_fourpillarsmediaagency_india"
    , "db_franticallyspeaking_india"
    , "db_galaxyerpsoftwaresolution_india"
    , "db_gardenparty_india"
    , "db_garimafashions_india"
    , "db_genmedshoppespvtltd_india"
    , "db_giversbayacademyllp_india"
    , "db_globaldiam_india"
    , "db_gokultexprintsprivatelimited_india"
    , "db_gopishripureghee_india"
    , "db_gorektechnologies_india"
    , "db_gouriwala_india"
    , "db_gramsproservepvtltd_india"
    , "db_greeni_india"
    , "db_gridkey_india"
    , "db_growit_india"
    , "db_halemons_india"
    , "db_harshresinstore_india"
    , "db_hayteesilkandsarees_india"
    , "db_heavensaurmitra_india"
    , "db_hisabkitabsupport_india"
    , "db_hnfashion_india"
    , "db_hotelmasinenigrand_india"
    , "db_houseofbrahma_india"
    , "db_houseofjersey_india"
    , "db_houseofunblurprivatelimited_india"
    , "db_itfuturz_india"
    , "db_itsbenclothingandapparelsprivatelimited_india"
    , "db_ivanajewels_india"
    , "db_jaamo_india"
    , "db_jaibholenathamd_india"
    , "db_jeetubhai_india"
    , "db_jewellerskartmaniwebsolutionspvtltd_india"
    , "db_jhajhufoodindustriesprivatelimited_india"
    , "db_jinkaltouch_india"
    , "db_joneliwis_india"
    , "db_juliecreation_india"
    , "db_kaambhari_india"
    , "db_kachapakkafashions_india"
    , "db_kalankit_india"
    , "db_kaldexlubricants_india"
    , "db_kantilalsawanthrajkothari_india"
    , "db_kasturidoriprivatelimited_india"
    , "db_kasvi_india"
    , "db_kavyaenterprise_india"
    , "db_kcjinternational_india"
    , "db_kdiamexim_india"
    , "db_kdilipkumaragency_india"
    , "db_kesariatexcoprivatelimited_india"
    , "db_keshavinternational_india"
    , "db_ketanadityatextilellp_india"
    , "db_khaitanjewels_india"
    , "db_khankesarmahal_india"
    , "db_kinggspire_india"
    , "db_kizzyfashion_india"
    , "db_klenterprise_india"
    , "db_krudratextiles_india"
    , "db_krushisharangagriclinicpvtltd_india"
    , "db_krutigarmentspvtltd_india"
    , "db_kymeelifestyleprivatelimited_india"
    , "db_laxmiblocksbuildingpvtltd_india"
    , "db_laxmipatigroup_india"
    , "db_littleindianspiceagropvtltd_india"
    , "db_livedigitalai_india"
    , "db_loftofspace_india"
    , "db_lvbindia_india"
    , "db_mahalaxmijyotishratankendra_india"
    , "db_mahalaxmitexfab_india"
    , "db_maharanibyrungtas_india"
    , "db_mahavirprints_india"
    , "db_maheshkumarmittalandco_india"
    , "db_mamabhanja_india"
    , "db_manka_india"
    , "db_mannukids_india"
    , "db_marwaricatalystsprivatelimited_india"
    , "db_marwaricatalystsprivatelimited2_india"
    , "db_matterblue_india"
    , "db_mayrakurtishub_india"
    , "db_meenaksiembrroideryyarn_india"
    , "db_mehtawealthlimited_india"
    , "db_mics_india"
    , "db_milkpalace_india"
    , "db_misrijaipur_india"
    , "db_mkbbook_india"
    , "db_mkfashion_india"
    , "db_mkfashionhub_india"
    , "db_mohitbhai_india"
    , "db_monubhaionlinekhaiwal_india"
    , "db_mrmanagers_india"
    , "db_multigrain_india"
    , "db_mybrandingcompany_india"
    , "db_mybrandingcompany2_india"
    , "db_myinvented_india"
    , "db_mymeet_india"
    , "db_myvaluetrip_india"
    , "db_nakodafashion_india"
    , "db_nakshfashionstudio_india"
    , "db_navitasgreensolutionsprivatelimited_india"
    , "db_neerajbhai_india"
    , "db_neonbanquets_india"
    , "db_netlinkitconsultancyprivatelimited_india"
    , "db_neverlook_india"
    , "db_nijshyamelectric_india"
    , "db_onedaydrycleaners_india"
    , "db_orangesky_india"
    , "db_ornezoornezo_india"
    , "db_otrodiamondsllp_india"
    , "db_outaloudwellnessservicesllp_india"
    , "db_ovalstarsentertainmentprivatelimited_india"
    , "db_paccificdevelopers_india"
    , "db_padmavathiinc_india"
    , "db_palevents_india"
    , "db_paninnodesignsllp_india"
    , "db_paninnodesignsllp2_india"
    , "db_paridhansareecollection_india"
    , "db_paryanirahulmurlidhar_india"
    , "db_prakruthcarepvtltd_india"
    , "db_prashvvita_india"
    , "db_premiumsystems_india"
    , "db_primafoodtechprivateltd_india"
    , "db_primexmediaservicespvtltd_india"
    , "db_propertyok_india"
    , "db_proventicssystemsprivatelimited_india"
    , "db_punjabiposhak_india"
    , "db_puzzleboxximpexprivatelimited_india"
    , "db_qlem_india"
    , "db_quadrantsofttechpvtltd_india"
    , "db_quantumitsolution_india"
    , "db_quickybowl_india"
    , "db_raajinvestment_india"
    , "db_rackupsystemsprivatelimited_india"
    , "db_rameshcreation_india"
    , "db_ranchigymkhanaclub_india"
    , "db_ra-reatra_india"
    , "db_referenceclub_india"
    , "db_referenceexpo_india"
    , "db_replayxexchangeco_india"
    , "db_reputesbusinesssolutions_india"
    , "db_respaceinfra_india"
    , "db_rogue360_india"
    , "db_rootz_india"
    , "db_royalpos_india"
    , "db_rra_finserv_private_limited_india"
    , "db_rupiyafinnovatonspvtltd_india"
    , "db_rushikjayeshbhaipatelhuf_india"
    , "db_rvkgsolutionspvtltd_india"
    , "db_sadbhavna_india"
    , "db_sambhavstudio_india"
    , "db_sangeettuneoftrends_india"
    , "db_sarthitoursandtravels_india"
    , "db_sattakingclub_india"
    , "db_satvachansarees_india"
    , "db_satyamfashion_india"
    , "db_scaryjeans_india"
    , "db_scrapbazar_india"
    , "db_semester_india"
    , "db_semsto_india"
    , "db_servall_india"
    , "db_shahpublicity_india"
    , "db_sharonservice_india"
    , "db_shilpkalafashionspvtltd_india"
    , "db_shinejewellimited_india"
    , "db_shreeannapurnastore_india"
    , "db_shreeganeshjaricoveringpvtltd_india"
    , "db_shreesationline_india"
    , "db_shuruup_india"
    , "db_shwetambariindia_india"
    , "db_siacreationlehenga_india"
    , "db_siriusjewelsandlifestylespvtltd_india"
    , "db_skkabraandcompany_india"
    , "db_solastajewellery_india"
    , "db_sptraders_india"
    , "db_stackby_india"
    , "db_startuparena_india"
    , "db_startupchaupal_india"
    , "db_stickymonkey_india"
    , "db_stratefixprofessionalprivatelimited_india"
    , "db_studiob_india"
    , "db_superrollingshutterpvtltd_india"
    , "db_suratjugaad_india"
    , "db_surbhitextilemillspvtltd_india"
    , "db_swanandpathologylaboratory_india"
    , "db_swarnimtouchsolutionspvtltd_india"
    , "db_swishindia_india"
    , "db_tansibalaji_india"
    , "db_tathastufab_india"
    , "db_thebiggrocer_india"
    , "db_thefamilymember_india"
    , "db_thefillingstation_india"
    , "db_thehindustandrycleaners_india"
    , "db_thenakhrastore_india"
    , "db_thetenthhouse_india"
    , "db_thunder_india"
    , "db_tidyup_india"
    , "db_toplineclothing_india"
    , "db_udayfashion_india"
    , "db_ultimatebusinesssystempvtltd_india"
    , "db_unisondeveloper_india"
    , "db_unwind_india"
    , "db_vegaautoaccessories_india"
    , "db_vijayenterprise_india"
    , "db_vimlaprints_india"
    , "db_vinayfashionllp_india"
    , "db_vishalbhai_india"
    , "db_visitorztechpvtltd_india"
    , "db_vittakosh_india"
    , "db_vncgems_india"
    , "db_vogzy_india"
    , "db_vunembroiderycords_india"
    , "db_westifiedtrend_india"
    , "db_whitehusk_india"
    , "db_wholetexoverseasprivatelimited_india"
    , "db_wibe2024_india"
    , "db_winhealthcare_india"
    , "db_workspaceco_india"
    , "db_yashimitation_india"
    , "db_yellowjerseyinvestmentadvisors_india"
    , "db_yummexports_india"
    , "db_yuvani_india"]

let commonPods = [
    "db_engees_ecommerce_india", "db_madshadestechnologiesprivatelimited_india", "db_oceanmtech_india", "db_sakhiyaskinclinic_india", "db_roongtadevelopers_india"
    , "db_unitedinfosenseprivatelimited_india", "db_varneegaurd_india", "db_zebralearnprivatelimited_india"
]

let ds11 = ["db_engeescommpvtltd_india"
    , "db_engeescommunications_india"
    , "db_engeesecompvtltd_india"
    , "db_madshadestechnologiesprivatelimited2_india"
    , "db_madshadestechnologiesprivatelimited3_india"
    , "db_madshadestechnologiespvtltd_india"
    , "db_oceanmtechprivatelimited2_india"
    , "db_sakhiyaskinclinic-bhatar_india"
    , "db_sakhiyaskinclinic-infinity_india"
    , "db_sakhiyaskincliniclimited_india"
    , "db_sakhiyaskinscience_india"
    , "db_techvizor_india"
    , "db_unitedinfosenseprivatelimited2_india"
    , "db_varniorganic_india"
    , "db_varnisolution_india"
    , "db_varnisolution2_india"
    , "db_zebralearnprivatelimited1_india"]
// deployment and service create and delete
const deploymentandservice = async () => {
    try {
        let primary = mongoConnection.useDb(constants.DEFAULT_DB);
        let alluserdata = await primary.model(constants.MODELS.users, users).find({ database: { $in: ds11 } }).lean();
        for (const data of alluserdata) {
            if (data.database) {
                console.log('-------------------------------------', data.database);
                let requests = {
                    "companyName": data.companyName,
                    "userId": data._id,
                    "subdomain": data.subdomain,
                    "hostUrl": 'statusmsg.11za.in',
                    // "hostUrl": 'statusmsg-internal.11za.in',
                    "ingressName": "engees11za-statusmsg-ingress",
                    "isDedicatedPod": true,
                    "serviceNameCommon": "engees11za-statusmsg-svc",
                    "dbInternal": true
                }
                let urlInternal = "https://kubernetesapp-internal.11za.in/";
                let urlProd = "https://kubernetesapp.11za.in/";
                // let resp = await superagent.post('http://localhost:3300/')
                let resp = await superagent.post(urlProd)
                    // let resp = await superagent.post(urlInternal + 'deleteDeploymentandService')
                    .set('Content-Type', 'application/json')
                    .send(requests);
                // console.log(resp);
            }
        }
        // for (let i = 1; i < 701; i++) {
        //     let requests = {
        //         "companyName": "test" + i,
        //         "userId": i
        //     }
        //     console.log(i);
        //     let resp = await superagent.post('https://kubernetesapp.11za.in/')
        //         //     // let resp = await superagent.post('https://kubernetesapp.11za.in/deleteDeploymentandService')
        //         .set('Content-Type', 'application/json')
        //         .send(requests);
        //     console.log(resp);

        // }
        // return response.onSuccess("key added successful", 1, res)
        console.log("success");
    } catch (err) {
        console.log("error::::", err);
    }
};

const countofThings = async () => {
    try {
        let primary = mongoConnection.useDb(constants.DEFAULT_DB);
        primary.model(constants.MODELS.users, users).find({}).select('_id mobileNo database').then(async (customerlist) => {
            for (let customer of customerlist) {
                const secondary = mongoConnection.useDb(customer.database);
                const [totalTemplateSended, customerCounts] = await Promise.all([
                    secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                        from: customer.mobileNo,
                        messageId: { $exists: true },
                        "content.contentType": "template",
                        sentTemplate: { $exists: true }
                    }),
                    // secondary.model(constants.MODELS.endcustomers, endCustomers).countDocuments({ isDelete: { $ne: true }})
                    secondary.model(constants.MODELS.endcustomers, endCustomers).countDocuments({ $or: [{ isDelete: false }, { isDelete: { $exists: false } }] })
                ])
                console.log(customer.database, ",", customer.mobileNo, ",", totalTemplateSended, ",", customerCounts);
            }
        }).catch((error) => { console.log("error111", error); });
    } catch (error) {
        console.error("error999", error);
    }
}

const countofUniquesCustomersFromAllDb = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ database: { $in: ['db_varnisolution_india', 'db_varneegaurd_india', 'db_varniorganic_india'] } }).select('mobileNo database').lean();
        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    let secondary = mongoConnection.useDb(userData.database);
                    console.log("userData----", userData.database);
                    let allCustomersData = await secondary.model(constants.MODELS.endcustomers, endCustomers).find({ $or: [{ isDelete: false }, { isDelete: { $exists: false } }] }).select('-_id').lean();
                    console.log("allCustomersData----", allCustomersData.length);
                    if (allCustomersData && allCustomersData.length > 0) {
                        let aa = await primary.model(constants.MODELS.allcustomers, endCustomers).insertMany(allCustomersData);
                        console.log("- afteer insert------", allCustomersData.length);
                        console.log("aa----", aa.length);
                    }
                } else {
                    console.log('user not found')
                }
            } catch (error) {
                console.error('error during getting user details', error)
            }
        }
        console.log('------------------------------------------------------end')
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
}

const BATCH_SIZE = 50000; // Define a suitable batch size

const countofUniquesCustomersFromAllDb111 = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({
            database: { $in: ['db_varnisolution_india', 'db_varneegaurd_india', 'db_varniorganic_india'] }
        }).select('mobileNo database').lean();

        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    let secondary = mongoConnection.useDb(userData.database);
                    console.log("userData----", userData.database);

                    // Get the count of documents to be processed
                    const totalDocuments = await secondary.model(constants.MODELS.endcustomers, endCustomers).countDocuments({
                        $or: [{ isDelete: false }, { isDelete: { $exists: false } }]
                    });

                    console.log(`Total documents to move from ${userData.database}:`, totalDocuments);

                    for (let i = 0; i < totalDocuments; i += BATCH_SIZE) {
                        let allCustomersData = await secondary.model(constants.MODELS.endcustomers, endCustomers)
                            .find({ $or: [{ isDelete: false }, { isDelete: { $exists: false } }] })
                            .select('-_id')
                            .lean()
                            .skip(i)
                            .limit(BATCH_SIZE);

                        console.log(`Processing batch ${i / BATCH_SIZE + 1} with ${allCustomersData.length} documents from ${userData.database}`);
                        console.log(allCustomersData.length);
                        if (allCustomersData && allCustomersData.length > 0) {
                            await primary.model(constants.MODELS.allcustomers, endCustomers).insertMany(allCustomersData);
                            console.log(`Batch ${i / BATCH_SIZE + 1} inserted successfully`);
                        }
                    }
                } else {
                    console.log('user not found');
                }
            } catch (error) {
                console.error('error during getting user details', error);
            }
        }
        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
};

const updateBroadcastStatusMissed = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        let allBroadcast = [
            // {
            //     broadcast_id: "66d7fefa9796ceabcdfb40cc",
            //     db_name: "db_bluenodeinfotechprivatelimited_india",
            // },
            {
                broadcast_id: "66d7fefa9796ceabcdfb40cc",
                db_name: "db_bluenodeinfotechprivatelimited_india",
            }];
        for (let Broadcast of allBroadcast) {
            try {
                if (Broadcast && Broadcast.db_name) {
                    let userData = await primary.model(constants.MODELS.users, users).findOne({ database: Broadcast.db_name }).lean();
                    let secondary = mongoConnection.useDb(userData.database);
                    console.log("DB Name =", userData.database);
                    const bid = Broadcast.broadcast_id;
                    let decryptedApiKey = await helper.apiKeyDecryptor(userData.apiKey);
                    console.log('decryptedApiKey', decryptedApiKey);
                    let broadcastdata = await secondary.model(constants.MODELS.broadcasts, broadcasts).findById(bid).lean();
                    if (broadcastdata != null) {
                        const messageIds = await secondary.model(constants.MODELS.inbounds, inBounds).find({ "broadcastData.broadcastId": config.mongoose.Types.ObjectId(bid) }, { "_id": 0, "messageId": 1 }).lean()
                        let AllMessageIds = messageIds.map(obj => obj.messageId)
                        let countofmsgs = 0;
                        if (AllMessageIds.length) {
                            const existingMessageIds = await secondary.model(constants.MODELS.msgstatus, msgStatus).find({ messageId: { $in: AllMessageIds } }).select('messageId');
                            // console.log(existingMessageIds);
                            for (const message of AllMessageIds) {
                                try {
                                    const messageIdExists = existingMessageIds.some((item) => item.messageId === message);
                                    // console.log('messageIdExists', messageIdExists, !messageIdExists)
                                    if (!messageIdExists) {
                                        countofmsgs++;
                                        console.log('messageno:', countofmsgs);
                                        let statusEvents = await superagent
                                            .get(process.env.META_BASE_URL + 'messages/' + message + '/events')
                                            .set('apikey', decryptedApiKey)
                                            .set('Content-Type', 'application/json;charset=utf8')
                                            .send();
                                        statusEvents = JSON.parse(statusEvents.text);
                                        console.log('statusEvents=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=========================================================');
                                        let { events, messageId } = statusEvents;
                                        console.log('events=-=-=-=-=-=-=-=-=-=-', events);
                                        // console.log('events=-=-=-seen', events.filter(event => event.event === 'MessageStatus::seen'));
                                        // console.log('events=-=-=-delivered', events.filter(event => event.event === 'MessageStatus::delivered'));
                                        // console.log('messageId', messageId);
                                        const latestEvent = events[events.length - 1].event;
                                        console.log('latestEvent', latestEvent);
                                        const eventStatusMap = {
                                            'MessageStatus::accepted': 'accepted',
                                            'MessageStatus::dispatched': 'accepted',
                                            'MessageStatus::delivered': 'delivered',
                                            'MessageStatus::seen': 'seen',
                                            'MessageStatus::channelFailed': 'failed',
                                            'MessageStatus::failed': 'failed'
                                        };
                                        let status = eventStatusMap[latestEvent] || '';
                                        await secondary.model(constants.MODELS.messageevents, messageEvents).findOneAndUpdate(
                                            { messageId },
                                            statusEvents,
                                            { upsert: true }
                                        );

                                        let latestIndex = events.length - 1;
                                        let event = events[latestIndex].event;
                                        let details = events[latestIndex].details
                                        let findIndex = events.findIndex((el) => el.event == 'MessageStatus::channelFailed')
                                        if (findIndex !== -1) {
                                            console.log("findIndex=-=-=-=", findIndex);
                                            latestIndex = findIndex;
                                            status = 'failed';
                                            event = 'MessageStatus::failed'
                                            details = events[findIndex].details
                                        }
                                        console.log("status", status);
                                        console.log("event", event);
                                        console.log("details", details);
                                        await secondary.model(constants.MODELS.msgstatus, msgStatus).findOneAndUpdate({ messageId: message }, {
                                            channel: 'whatsapp',
                                            status,
                                            timestamp: events[events.length - 1].timestamp,
                                            event: event,
                                            details: details
                                        }, { upsert: true });
                                    }
                                } catch (err) {
                                    console.log('error in messId Loop', err)
                                }
                            }
                        }
                    } else {
                        console.log('in else')
                    }
                } else {
                    return response.onSuccess("User not found!", 1, res);
                }
            } catch (err) {
                console.log('error in Broadcast Loop', err)
            }
        }
        console.log('Completed all updation:::::::::')
    } catch (error) {
        console.log('Error during updation:::::::::', error)
    }
};

const priceUpdateofLast3Days = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        // db_cmansukhlaljewellers_india
        let userDataAll = await primary.model(constants.MODELS.users, users).find({ database: { $ne: "db_farmhousehub_india" } }).lean();
        for (let userData of userDataAll) {
            try {
                let secondary = mongoConnection.useDb(userData.database);
                console.log("DB Name ==-=-=-=-=-=-=-=-=-=-", userData.database);
                let startDate = new Date(1726252195 * 1000).getTime();
                let endDate = new Date(1721724004 * 1000).getTime();
                let startDateUTC = new Date(startDate).toISOString();
                let endDateUTC = new Date(endDate).toISOString();
                const MessageStatusAll = await secondary.model(constants.MODELS.msgstatus, msgstatusModel).aggregate([
                    {
                        $match: {
                            status: { $in: ['delivered', 'seen'] },
                            "whatsapp.billable": true,
                            // "whatsapp.conversation.origin": { $ne: 'service' },
                        }
                    },
                    {
                        $addFields: {
                            dateTimeStamp: {
                                $toDate: "$timestamp"
                            }
                        }
                    },
                    {
                        $match: {
                            dateTimeStamp: {
                                $gte: new Date(startDateUTC),
                                // $lte: new Date(endDateUTC)
                            }
                        }
                    },
                ]);

                // console.log(MessageStatusAll);
                console.log("MessageStatusAll.length", MessageStatusAll.length);
                if (MessageStatusAll.length) {
                    let countofnotfound = 0;
                    let countoffound = 0;
                    let messageCost1 = 0;
                    let allConversations = [];
                    let allExistingConversationsArray = [];
                    allConversations = MessageStatusAll.map((message) => message.whatsapp.conversationId);
                    allConversations = [...new Set(allConversations)];
                    let allExistingConversations = await secondary.model(constants.MODELS.balanceuses, balanceModel).find({ "whatsapp.conversationId": { $in: allConversations } }).select({ _id: 1, "whatsapp.conversationId": 1 }).lean();
                    allExistingConversationsArray = allExistingConversations.map((conversation) => conversation.whatsapp.conversationId);
                    // console.log("allConversations", allConversations);
                    // console.log("allExistingConversationsArray", allExistingConversationsArray);
                    for (let message of MessageStatusAll) {
                        try {
                            if (message?.whatsapp?.conversationId) {
                                // let existingConversation = await secondary.model(constants.MODELS.balanceuses, balanceModel).findOne({ "whatsapp.conversationId": message.whatsapp.conversationId }).select({ _id: 1 }).lean();
                                let existingConversation = allExistingConversationsArray.includes(message.whatsapp.conversationId);
                                if (!existingConversation) {
                                    allExistingConversationsArray.push(message.whatsapp.conversationId);
                                    countofnotfound++;
                                    delete message._id;
                                    delete message.__v;
                                    delete message.updatedAt;
                                    message.timestamp = new Date(message.timestamp);
                                    messageCost1 = messageCost1 + await this.pricingModel(message, primary, secondary, userData);
                                } else {
                                    countoffound++;
                                    // console.log('in else and found in db balanceModel', message.whatsapp.conversationId);
                                }
                            } else {
                                console.log("eorrorororor", message);
                            }

                        } catch (err) {
                            console.log('error in Broadcast Loop', err)
                        }
                    }
                    console.log("messageCost1", messageCost1);
                    console.log('countofnotfound', countofnotfound);
                    console.log('countoffound', countoffound);
                }
            } catch (err) {
                console.log('error in Broadcast Loop', err)
            }
        }
        console.log('Completed all updation:::::::::')
    } catch (error) {
        console.log('Error during updation:::::::::', error)
    }
};

exports.pricingModel = async (messageStatus, primary, secondary, productUser) => {
    // console.log("messageStatus before=-=-=-=-=-", messageStatus);
    let ir = "uir_inr";
    if (messageStatus.whatsapp.conversation.origin == 'service') {
        ir = "sir_inr";
    } else if (messageStatus.whatsapp.conversation.origin == 'marketing') {
        ir = "mir_inr";
    } else if (messageStatus.whatsapp.conversation.origin == 'authentication') {
        ir = "air_inr";
    }
    let productUserMain = await primary.model(constants.MODELS.users, users).findOne({ _id: productUser._id }).select("currentMonthFreeMessages").lean();
    if (productUserMain.currentMonthFreeMessages > 0 && messageStatus.whatsapp.conversation.origin == 'service') {
        // const decrementedValue = productUserMain.currentMonthFreeMessages - 1;
        // console.log("decrementedValue", decrementedValue);
        // delete messageStatus.isPaidTemplate;
        // await primary.model(constants.MODELS.users, users).updateOne(
        //     { _id: productUser._id },
        //     { $set: { currentMonthFreeMessages: decrementedValue } }
        // );
        // await secondary.model(constants.MODELS.msgstatus, msgStatus)
        //     .updateOne(
        //         { messageId: messageStatus.messageId },
        //         {
        //             $set: { isPaidTemplate: false },
        //             $setOnInsert: { ...messageStatus },
        //         },
        //         { upsert: true }
        //     );

        return 0
    } else {
        delete messageStatus.isPaidTemplate;
        // await secondary.model(constants.MODELS.msgstatus, msgStatus)
        //     .updateOne(
        //         { messageId: messageStatus.messageId },
        //         {
        //             $set: { isPaidTemplate: true },
        //             $setOnInsert: { ...messageStatus },
        //         },
        //         { upsert: true }
        //     );
        const country_code = [91, 1, 44, 971, 92]
        let flag = false;
        for await (let code of country_code) {
            if (messageStatus.from.startsWith(code)) {
                let country_cost = await primary.model(constants.MODELS.countries, countries).findOne({ countrycallingcode: String(code) }).lean();
                messageStatus.messageCost = parseFloat(country_cost[ir]);
                messageStatus.country_code = String(code)
                if (country_cost.parent != null) {
                    let parent = await primary.model(constants.MODELS.countries, countries).findById(country_cost.parent).lean();
                    messageStatus.messageCost = parseFloat(parent[ir]);
                    messageStatus.country_code = String(country_cost.countrycallingcode)
                } else {
                    messageStatus.messageCost = parseFloat(country_cost[ir]);
                    messageStatus.country_code = String(country_cost.countrycallingcode)
                }
                flag = true;
                break;
            }
        }
        if (flag == false) {
            let allCountries = await primary.model(constants.MODELS.countries, countries).find({ countrycallingcode: { $ne: '' } }).lean();
            await async.forEachSeries(allCountries, (country, next_countryx) => {
                (async () => {
                    if (messageStatus.from.startsWith(country.countrycallingcode)) {
                        if (country.parent != null) {
                            let parent = await primary.model(constants.MODELS.countries, countries).findById(country.parent).lean();
                            messageStatus.messageCost = parseFloat(parent[ir]);
                            messageStatus.country_code = country.countrycallingcode
                        } else {
                            messageStatus.messageCost = parseFloat(country[ir]);
                            messageStatus.country_code = country.countrycallingcode
                        }
                    }
                    next_countryx();
                })().catch((error) => { console.log('error:', error) });
            });
        }
        // console.log("messageStatus after cost", messageStatus);
        // await secondary.model(constants.MODELS.balanceuses, balanceModel).create(messageStatus);
        // console.log("messageStatus after cost", messageStatus.messageId, messageStatus.messageCost);
        return messageStatus.messageCost
    }
}

const productSyncCheckFunNoUse = async () => {
    const accessToken = 'EAAXrdd63bq4BADg1jhZBdxP2ZBvdLaswWJ7WihKAQNXdw3RXMRkMVZCXrCmt99CK1WtmbZARQkZCs6LNy43wcmwxuYsaiWE2slH6lGZAKzZAUtvvOuyQEeHXjZCS3R0DDeuSQDxHaitcb78TvpWlIYuXluZBFxFZCPqS0qP3N1IAx7BioSDVeudcqd';
    const catalogId = '7075568692473825';
    const url = `https://graph.facebook.com/v17.0/${catalogId}/products`;
    const params = {
        access_token: accessToken,
        fields: 'id,retailer_id,name,image_url,sale_price,brand,category,color,currency,condition,description,availability,applinks,price,origin_country,inventory,quantity_to_sell_on_facebook,shipping_weight_unit,shipping_weight_value,url,visibility,wa_compliance_category,retailer_product_group_id'
    };
    // Function to make the API request
    async function getLeadData(url, params) {
        try {
            const response = await axios.get(url, { params });
            return response.data;
        } catch (error) {
            throw error;
        }
    }
    // Recursive function to handle pagination
    async function getAllLeadData(url, params) {
        let allData = [];
        let nextPage = url;
        while (nextPage) {
            try {
                const data = await getLeadData(nextPage, params);
                allData = allData.concat(data.data);
                if (data.paging && data.paging.next) {
                    nextPage = data.paging.next;
                } else {
                    nextPage = null;
                }
            } catch (error) {
                throw error;
            }
        }
        return allData;
    }
    (async () => {
        try {
            const allLeads = await getAllLeadData(url, params);
            console.log('allLeads', allLeads.length);
            console.log('sxdfgdfgdfgdfgfd', allLeads);
            async.forEachSeries(allLeads, (allLead, next_allLeads) => {
                console.log(allLead);
                const priceString = allLead.price;
                const priceWithoutCurrencySymbol = priceString.replace('₹', ''); // Remove the currency symbol
                const priceNumber = parseFloat(priceWithoutCurrencySymbol); // Parse the string as a float
                // if (allLead.retailer_id == 47037484106018) {
                //     console.log('allLead', allLead);
                //     next_allLeads();
                // } else {
                //     console.log('allLead.retailer_id::::::::::::::::', allLead.retailer_id);
                next_allLeads();
                // }
            }, () => {
                console.log('DONE::::::::::::::::::::::::::');
            });
            // Process and analyze the lead data
        } catch (err) {
            console.error('Error:', err.message);
        }
    })();
}
const catalogId = '3210584022546342';
const authTokenDynamic = "U2FsdGVkX18GqBqWt3ctg4llfnjNuw6HEipLhvY40Q8Xydz58300PzdQJ08hZgBZgOAgi7zGUpqzl2oqNbrPhZzatzk13Wa9sDAH60F6UhbiOYMSgY/7zrpBCgBg9q9ctKWCRylMTzoGuQufHLebtzzrHe4GXQPwaygtwXNnQK0NrX1ko+0CBI0lMYJmTlkh"
const productSyncFun = async () => {
    // let image = "https://scontent.fstv5-1.fna.fbcdn.net/v/t45.5328-4/449179908_888817566612280_6027108019862943726_n.jpg?_nc_cat=102&ccb=1-7&_nc_sid=c7e7b7&_nc_ohc=cUGVHLd9yxcQ7kNvgHA2d9U&_nc_ht=scontent.fstv5-1.fna&cb_e2o_trans=q&edm=ANyJclEEAAAA&oh=00_AYAh9qJ8yfhKBf3Chk3Cw1282DOp5ntRngB02BsbH2Emwg&oe=669BE0E9"
    // let filemime = mime.getType(imageUrl);
    // let fileType = helper.getFileType(filemime);
    // console.log('filemime', filemime);
    // console.log('fileType', fileType);
    // let response = await axios.get(image, { responseType: 'arraybuffer' });
    // let buffer = Buffer.from(response.data, "utf-8");
    // console.log("mime.getType(image)", mime.getType(image));
    // let filemime = mime.getType(image) || response.headers['content-type'];
    // console.log(filemime);
    // let filesize = parseFloat(parseFloat(buffer.toString().length) / 1000000);
    // let uploadResult = await AwsCloud.saveToS3(buffer, "dhananjaybathfittingindai", filemime, 'ProductImages');
    // console.log('uploadResult', uploadResult);
    // return
    // if (!filemime || !fileType) {
    //     axios.get(imageUrl, { responseType: 'arraybuffer' }).then((response) => {
    //         const contentType = response.headers['content-type'];
    //         console.log('contentType', contentType);
    //     }).catch((error) => {
    //         console.log(error.message);
    //     });
    // }
    // return
    const accessToken = 'EAAXrdd63bq4BOZClF1qGvftupzoppJcb273TRkMNBE0XwnJQSZBqLXaCI89QZAn2BVAylZCy8ti9cqOaXWTmMUhc51515FzNNxCGpvocOu8D9gOjWlfC8ves1dWCmHlaix0FIRQ65GZCs7dYAlfuzs4pbCa4hHZC3eKLIbS6K1kr0lD5PVSl90IiBb64JZAUf1K';
    const url = `https://graph.facebook.com/v20.0/${catalogId}/products`;
    const params = {
        access_token: accessToken,
        bulk_pagination: true,
        limit: 500,
        fields: 'id,retailer_id,name,image_url,sale_price,brand,category,color,currency,condition,description,availability,applinks,price,origin_country,inventory,quantity_to_sell_on_facebook,shipping_weight_unit,shipping_weight_value,url,visibility,wa_compliance_category,retailer_product_group_id'
    };
    // Function to make the API request
    async function getLeadData(url, params) {
        try {
            // console.log("params", params);
            // const response = await axios.get(url, { params });
            const response = await superagent.get(url).query(params);
            // console.log("response.text.data", response.text);
            // console.log(JSON.parse(response.text));
            return JSON.parse(response.text);
        } catch (error) {
            console.log("error=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-", error.message);
            throw error;
        }
    }
    // Recursive function to handle pagination
    async function getAllLeadData(url, params) {
        let allData = [];
        let nextPage = url;
        while (nextPage) {
            try {
                console.log("allData.length getLeadData", allData.length);
                const data = await getLeadData(nextPage, params);
                // console.log("data.data", data);
                allData = allData.concat(data.data);
                // console.log("data.paging.next", data?.paging?.next);
                if (data.paging && data.paging.next) {
                    nextPage = data.paging.next;
                    // nextPage = 0;
                } else {
                    nextPage = null;
                }
            } catch (error) {
                throw error;
            }
        }
        return allData;
    }
    (async () => {
        try {
            const allLeads = await getAllLeadData(url, params);
            // console.log('allLeads', allLeads);
            console.log('allLeads.length 1111111111111', allLeads.length);
            // let allLeads1 = allLeads.filter(el => arr1Saud.includes(el.retailer_id))
            // console.log("allLeads1",allLeads1);
            // console.log(allLeads1.length);
            // return;
            for (let allLead of allLeads) {
                // if (true) {
                if (allLead.retailer_id != '37431241539738') {
                    // if (allLead.retailer_id == '37431241539738') {
                    console.log(" Wait for 5 seconds (5000 milliseconds)");
                    await new Promise((resolve) => {
                        setTimeout(resolve, 500);
                    });
                    console.log("lead before=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-", allLead);
                    const priceString = allLead.price;
                    let sale_priceString = (allLead.sale_price) ? allLead.sale_price.replace(/[^\d.-]/g, '') : "";
                    const priceWithoutCurrencySymbol = priceString.replace(/[^\d.-]/g, ''); // Remove the currency symbol
                    const priceNumber = parseFloat(priceWithoutCurrencySymbol); // Parse the string as a float
                    let imageUrl = '';
                    if (allLead.image_url) {
                        if (allLead.image_url.includes("?v=")) {
                            imageUrl = allLead.image_url.split("?v=")[0];
                        } else {
                            imageUrl = allLead.image_url
                        }
                    }
                    console.log('imageUrl', imageUrl);
                    if (!allLead.brand) {
                        allLead.brand = "zebralearn"
                    }
                    let sku = allLead.brand + '' + allLead.retailer_id;
                    sku = sku.replace(/\s+/g, '');
                    let data = JSON.stringify({
                        "authToken": authTokenDynamic,
                        "title": allLead.name,
                        "productId": (allLead.retailer_id) ? allLead.retailer_id : "",
                        "facebookResponseId": allLead.id ? allLead.id : "",
                        "qty": allLead.inventory ? allLead.inventory : 0,
                        "description": allLead.description,
                        "productUrl": allLead.url,
                        // "image": allLead.image_url,
                        "saleprice": sale_priceString,
                        "image": imageUrl,
                        "otherimages": "",
                        "price": priceNumber,
                        "sku": sku,
                        "category": allLead.brand,
                        "childcategory": "",
                        "weighttype": "kg",
                        "availibility": allLead.availability,
                        "condition": allLead.condition,
                        "currency": allLead.currency,
                        "country": allLead.origin_country ? allLead.origin_country : "IN",
                        "productStatus": "active",
                        "platform": "Facebook Sync",
                        "groupId": "",
                        "variants": [],
                        "ManufacturerInfo": "",
                        "ImporterName": "",
                        "ImporterAddressStreet1": "",
                        "ImporterAddressStreet2": "",
                        "ImporterAddressCity": "",
                        "ImporterAddressRegion": "",
                        "ImporterAddressPostalCode": "",
                        "ImporterAddressCountry": ""
                    });
                    // console.log('data to be sent', JSON.parse(data));
                    let config = {
                        method: 'post',
                        maxBodyLength: Infinity,
                        url: 'https://app.11za.in/apis/product/add',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        data: data
                    };
                    console.log("config", config);
                    axios.request(config)
                        .then((response) => {
                            console.log(JSON.stringify(response.data));
                        })
                        .catch((error) => {
                            console.log('ERRRRRRRRRRRRRRRRRRRRR', error);
                        });
                    // break;
                } else {
                    console.log('else =-=-=-allLead.retailer_id::::::::::::::::', allLead.retailer_id);
                }
            }
        } catch (err) {
            console.error('Error:', err);
        }
    })();
}

const priceUpdateofLast3Day111s = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        // db_cmansukhlaljewellers_india
        let userDataAll = await primary.model(constants.MODELS.users, users).find({ database: "db_farmhousehub_india" }).lean();
        for (let userData of userDataAll) {
            try {
                let secondary = mongoConnection.useDb(userData.database);
                console.log("DB Name ==-=-=-=-=-=-=-=-=-=-", userData.database);
                const allIDS = await secondary.model(constants.MODELS.balanceuses, balanceModel).aggregate([
                    {
                        $match: {
                            createdAt: { $gt: new Date("2024-09-13T18:29:55.000Z") },
                            "whatsapp.billable": true,
                            "whatsapp.conversation.origin": "marketing"
                        }
                    },
                    {
                        $group: {
                            _id: "$details.from",  // Group by "details.from"
                            count: { $sum: 1 },  // Count the number of documents in each group
                            ids: { $push: "$_id" }  // Collect all _id values into an array
                        }
                    },
                    {
                        $match: { count: { $gt: 1 } }  // Only return groups with more than one document
                    },
                    {
                        $group: {
                            _id: null,  // No specific grouping in this final stage
                            allIds: { $push: { $arrayElemAt: ["$ids", 0] } }  // Push the first _id of each group into an array
                        }
                    }
                ])
                console.log("allIDS", allIDS);
                console.log(allIDS[0].allIds);
                await secondary.model(constants.MODELS.balanceuses, balanceModel).deleteMany({ _id: { $in: allIDS[0].allIds } })
            } catch (err) {
                console.log('error in Broadcast Loop', err)
            }
        }
        console.log('Completed all updation:::::::::')
    } catch (error) {
        console.log('Error during updation:::::::::', error)
    }
};
const countofUsersDeactivated = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const alluserdata = await primary.model(constants.MODELS.users, users).find({ accountStatus: true }).select('mobileNo database accountStatus').lean();
        let date1 = new Date(1706725800 * 1000);
        let date2 = new Date(1704047400 * 1000);
        console.log(date1);
        console.log(date2);

        // Create an array to store the data for the table
        let tableData = [];
        let dbwith0Inbounds = []

        for (let userData of alluserdata) {
            try {
                if (userData && userData.mobileNo) {
                    let secondary = mongoConnection.useDb(userData.database);
                    // Get the count of documents to be processed
                    // const totalDocuments = await secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                    //     timestamp: { $gt: date1.getTime() }
                    // });
                    // const totalDocuments1 = await secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                    //     timestamp: { $gte: date2.getTime(), $lte: date1.getTime() }
                    // });
                    // const totalDocuments2 = await secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                    //     timestamp: { $gte: date2.getTime() }
                    // });
                    // if (totalDocuments > 0 && userData.accountStatus == false) {
                    //     dbwith0Inbounds.push(userData.database)
                    // }
                    // const lastInbound = await secondary.model(constants.MODELS.inbounds, inBounds).find({}).sort({ _id: -1 }).limit(1);
                    // Add data to tableData array
                    // tableData.push({
                    //     Database: userData.database,
                    //     'from Jan 31': totalDocuments,
                    //     'from Dec 31 to Jan 31 ': totalDocuments1,
                    //     // 'Total Inb': totalDocuments2,
                    //     // 'Last Inb': lastInbound.length ? new Date(lastInbound[0].timestamp).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }) : 'NA',
                    //     "Status": userData.accountStatus
                    // });

                    const totalDocuments = await secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                        timestamp: { $gte: new Date(1717180200 * 1000).getTime(), $lt: new Date(1719772200 * 1000).getTime() }
                    });
                    const totalDocuments2 = await secondary.model(constants.MODELS.inbounds, inBounds).countDocuments({
                        timestamp: { $gte: new Date(1719772200 * 1000).getTime() }
                    });
                    tableData.push({
                        Database: userData.database,
                        'June 1 to june 30': totalDocuments,
                        'July 1 to Aug 14 ': totalDocuments2,
                        // 'Total Inb': totalDocuments2,
                        // 'Last Inb': lastInbound.length ? new Date(lastInbound[0].timestamp).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }) : 'NA',
                        "Status": userData.accountStatus
                    });

                } else {
                    console.log('user not found');
                }
            } catch (error) {
                console.error('error during getting user details', error);
            }
        }

        // Display the data as a table
        console.table(tableData);
        // console.log(dbwith0Inbounds);
        // let data = JSON.stringify(dbwith0Inbounds);
        // console.log(data);
        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
};


const templatePayloadAdd = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        const { v1: uuidv1 } = require('uuid');
        console.log("uuidv1", uuidv1);
        let userdata = await primary.model(constants.MODELS.users, users).find({}).select('database').lean();
        console.log("userdata", userdata.length);
        if (userdata && userdata.length) {
            let customerArray = []
            for (const user of userdata) {
                let secondary = mongoConnection.useDb(user.database);
                const getTemplate = await secondary.model(constants.MODELS.templates, templates).find({}).sort({ _id: -1 }).lean();
                console.log("getTemplate----", getTemplate.length);
                let carouselTempArray = []
                let btnTempArray = []
                if (getTemplate.length) {
                    for (const temp of getTemplate) {
                        let flag1 = false
                        let flag2 = false
                        if (temp.localizations) {
                            for (const localization of temp.localizations) {
                                for (const component of localization.components) {
                                    if (component.type == 'BUTTONS') {
                                        component.buttons.map((button) => {
                                            if (button.type == 'QUICK_REPLY') {
                                                flag2 = true
                                                button.payload = button?.payload ?? uuidv1()
                                            }
                                        })
                                    }
                                    if (component.type == 'CAROUSEL') {
                                        component.cards.map((card) => {
                                            if (card.components[2].type == 'BUTTONS') {
                                                card.components[2].buttons.map((btn) => {
                                                    if (btn.type === 'QUICK_REPLY') {
                                                        flag1 = true
                                                        btn.payload = btn?.payload ?? uuidv1()
                                                    }

                                                })
                                            }
                                        })
                                    }
                                }
                            }
                        }
                        if (flag1) {
                            carouselTempArray.push(temp.name)
                        }
                        if (flag2) {
                            btnTempArray.push(temp.name)
                        }
                        await secondary.model(constants.MODELS.templates, templates).updateOne(
                            { _id: temp._id },
                            { $set: { localizations: temp.localizations } }
                        );
                    }
                }
                customerArray.push({ database: user.database, 'Button Template': btnTempArray, 'Button Template Length': btnTempArray.length, 'Carousel template': carouselTempArray, 'Carousel Template Length': carouselTempArray.length })
            }
            console.log('::::::::::customerArray::::::::::::::', JSON.stringify(customerArray));
            console.log("customerArray-=========================================", customerArray);
        }
        console.log('------------------------------------------------------end');
    } catch (error) {
        console.error('Error in duplicateCustomers api', error);
    }
};

const referral_conversionChargeCalculate = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        let userDataAll = await primary.model(constants.MODELS.users, users).find({ database: 'db_farmhousehub_india' }).select('database').lean();
        let arr = []
        for (let userData of userDataAll) {
            try {
                let secondary = mongoConnection.useDb(userData.database);
                const walletBalance = await getwalletBalance(secondary);
                console.log(userData.database, ":- ", parseFloat(walletBalance));
                if (walletBalance) {
                    arr.push({ Client: userData.database, referral_conversion_Charge: parseFloat(Number(walletBalance).toFixed(2)) })
                    let deleted = await secondary.model(constants.MODELS.balanceuses, balanceModel).find({
                        "whatsapp.conversation.origin": "referral_conversion",
                        "whatsapp.billable": { $in: [false, null] },
                    });
                    // await secondary.model(constants.MODELS.balanceuses, balanceModel).deleteMany({
                    //     "whatsapp.conversation.origin": "referral_conversion",
                    //     "whatsapp.billable": { $in: [false, null] },
                    // });
                    console.log("deleted=-=-2", deleted.length);
                }
            } catch (err) {
                console.log('error in Broadcast Loop', err)
            }
        }
        console.table(arr);
        console.log('Completed all updation:::::::::')
    } catch (error) {
        console.log('Error during updation:::::::::', error)
    }
};

const getwalletBalance = async (secondary) => {
    try {
        const cost = await secondary.model(constants.MODELS.balanceuses, balanceModel).aggregate([
            {
                $match: {
                    "whatsapp.conversation.origin": "referral_conversion",
                    // "whatsapp.billable": { $in: [false, null] },
                }
            },
            { $group: { _id: null, cost: { $sum: "$messageCost" }, count: { $sum: 1 } } }
        ]);
        console.log("deleted=-=-1", cost.length);
        const totalCost = cost.length > 0 ? cost[0].cost : 0;
        return totalCost;
    } catch (err) {
        console.error('Error in currentWalletBalance function', err);
        throw err;
    }
}

const setdedicatedPODtoUsers = async () => {
    try {
        const primary = mongoConnection.useDb(constants.DEFAULT_DB);
        let allPODsSettings = await primary.model('configdatas', commonMODEL).find({ "isDedicatedPod": true }).lean();
        // console.log(allPODsSettings);
        console.log(allPODsSettings.length);
        for (let pod of allPODsSettings) {
            try {
                let userData = await primary.model(constants.MODELS.users, users).findById(pod.parentId);
                if (userData) {
                    console.log("userData.database", userData.database);
                    await primary.model(constants.MODELS.users, users).updateOne({ _id: pod.parentId }, { $set: { "havededicatedpod": true } });
                }
            } catch (err) {
                console.log('error in Broadcast Loop', err)
            }
        }
        console.log('Completed all updation:::::::::')
    } catch (error) {
        console.log('Error during updation:::::::::', error)
    }
};

async function customFunction() {
    await new Promise((resolve) => {
        setTimeout(resolve, 2000); // Wait for 5 seconds (5000 milliseconds)
    });
    // duplicateCustomers();
    // createContainer();
    // updateDataStoreName();
    // addAdressinUsers();
    // abcHitShopify();
    // getLastestMessageStatusTime();
    // addPlanDetails();
    // addAdminTransactionDetails();
    // addPermissionExport();
    // razorpay_payment_id();
    // addpermissionobjectinTeammembers();
    // userswithonlywlletfalseandstatustrue();
    // duplicateCustomers();
    // keyAddMetaTemp();
    // testLoop();
    // newLoop();
    // deploymentandservice();
    // countofThings();
    // countofUniquesCustomersFromAllDb();
    // countofUniquesCustomersFromAllDb111();
    // duplicateCustomersinEngees();
    // updateBroadcastStatusMissed();
    // priceUpdateofLast3Days();
    // productSyncFun();
    // countofUsersDeactivated();
    // templatePayloadAdd();
    // referral_conversionChargeCalculate()
    // setdedicatedPODtoUsers();
    // priceUpdateofLast3Day111s()
    // updateWalletPermission();
    console.log('customFunction------------------------------');
}

customFunction();
